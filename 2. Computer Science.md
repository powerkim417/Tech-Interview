# 2. Computer Science

## Computer Architecture 컴퓨터 구조

### 컴퓨터의 구성

하드웨어 + 소프트웨어

- 하드웨어: 컴퓨터를 구성하는 기계적 장치
- 소프트웨어: 하드웨어의 동작을 지시하고 제어하는 **명령어의 집합**
  - 시스템 소프트웨어: 운영체제, 컴파일러
  - 응용 소프트웨어: 워드프로세서, 스프레드시트

#### 하드웨어

<img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201013190232322.png" alt="image-20201013190232322" style="zoom: 67%;" />

중앙처리장치 + 기억장치 + 입출력장치

- 시스템 버스로 연결되어 있음
  - 데이터와 명령 제어 신호를 각 장치로 실어나르는 역할

##### 중앙처리장치(CPU)

산술논리연산장치(ALU) + 제어장치 + 레지스터

- 컴퓨터의 두뇌에 해당하는 부분
- 주기억장치에서 명령어와 데이터를 읽어와 처리, 명령어의 수행 순서 제어
- **ALU**: 비교와 연산 담당
- **제어장치**: 명령어의 해석/실행 담당
- **레지스터**: 속도가 빠른 데이터 기억 장소

##### 기억장치

주기억장치 + 보조기억장치

- 프로그램, 데이터, 연산 중간 결과를 저장하는 장치
- **주기억장치**
  - Ex) RAM, ROM
  - 실행중인 프로그램과 같은 <u>프로그램에 필요한 데이터를 일시적으로 저장</u>
- **보조기억장치**
  - Ex) HDD
  - 주기억장치보다 <u>느리지만</u> 많은 자료를 <u>영구적으로 보관</u>할 수 있음

##### 입출력장치

입력장치 + 출력장치

- **입력장치**: 컴퓨터 내부로 자료 입력(Ex. 키보드, 마우스, ...)
- **출력장치**: 컴퓨터 외부로 자료 표현(Ex. 프린터, 모니터, ...)

#### 시스템 버스

하드웨어 구성요소를 <u>물리적으로 연결</u>하는 선

##### 데이터 버스

<u>중앙처리장치</u>와 <u>기타 장치</u>(기억장치, 입출력장치) 사이에서 데이터 전달

- <u>양방향</u> 버스

##### 주소 버스

데이터를 정확하게 나르기 위해서 <u>기억장치의 주소를 전달</u>하는 통로

- 중앙처리장치 → 주기억장치, 입출력장치(<u>단방향</u> 버스)

##### 제어 버스

중앙처리장치가 기타 장치에 제어 신호를 전달하는 통로

- 데이터 버스와 주소 버스는 모든 장치에 공유되므로 이를 제어하는 수단

- 읽기, 쓰기 모두 수행(<u>양방향</u> 버스)
- 제어 신호 종류: 기억장치 읽기 및 쓰기, 버스 요청 및 승인, 인터럽트 요청 및 승인, 클락, 리셋, ...

#### 컴퓨터의 데이터 처리

읽고 처리한 뒤 저장 READ → PROCESS → WRITE

- 이 과정에서 끊임없이 주기억장치(RAM)과 소통
- 운영체제가 64bit라면 CPU는 RAM으로부터 데이트를 한번에 64bit씩 읽어옴 

### 중앙처리장치(CPU) 작동 원리

#### 각 장치의 특징 및 역할

##### 연산 장치(ALU)

- 산술 연산과 논리 연산 수행
- 연산에 필요한 데이터를 레지스터에서 가져오고, 연산 결과를 다시 레지스터로 보냄

##### 제어 장치

- 명령어를 순서대로 실행할 수 있도록 제어
- 주기억장치에서 명령어를 꺼내 해독하고, 그 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄
- 장치들이 보낸 신호를 받아 다음에 수행할 동작을 결정

##### 레지스터

- 고속 기억장치
- 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장
- CPU 종류에 따라 사용할 수 있는 레지스터 갯수와 크기가 다름
- 범용 레지스터: 연산에 필요한 데이터나 연산 결과를 임시로 저장
- 특수목적 레지스터: 특별한 용도로 사용하는 레지스터
  - MAR(메모리 주소 레지스터): <u>읽기/쓰기 연산을 수행할 주기억장치 주소</u> 저장
  - PC(프로그램 카운터): <u>다음에 수행할 명령어 주소</u> 저장
  - IR(명령어 레지스터): <u>현재 실행중인 명령어</u> 저장
  - MBR(메모리 버퍼 레지스터): <u>주기억장치에서 읽어온 데이터 또는 주기억장치에 저장할 데이터</u>를 임시로 저장
  - AC(누산기): <u>연산 결과를 임시로</u> 저장

#### CPU의 동작 과정

1. 주기억장치: 입력장치에서 입력받은 데이터 or 보조기억장치에 저장된 프로그램을 읽어옴
2. CPU: 프로그램을 실행하기 위해 주기억장치에 저장된 명령어와 데이터를 읽어와 처리. 그 결과를 다시 주기억장치에 저장
3. 주기억장치: 처리 결과를 보조기억장치에 저장하거나 출력장치로 보냄
4. 제어장치: 1~3 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어

#### 명령어 세트

CPU가 실행할 명령어의 집합, 연산 코드(Operation Code) + 피연산자(Operand)로 이루어짐

- 연산 코드: 실행할 연산
  - 연산, 제어, 데이터 전달, 입출력 기능
- 피연산자: 데이터 or 저장 위치
  - 주소, 숫자/문자, 논리 데이터 등 저장
- CPU는 프로그램을 실행하기 위해 '주기억장치에서 명령어를 순차적으로 인출하여 해독하고 실행하는 과정'을 반복
- 명령어 사이클: CPU가 주기억장치에서 한번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동
  - Fetch / Execute / Indirect / Indirect 사이클로 나누어짐
  - 주기억장치의 지정된 주소에서 하나의 명령어를 가져오고, Execute 사이클에서는 명령어를 실행함. 하나의 명령어 실행이 완료되면 그 다음 명령어에 대한 Fetch 사이클 시작

##### Fetch 사이클과 Execute 사이클에 의한 명령어 처리 과정

###### Fetch

1. PC에 저장된 주소를 MAR로 전달
2. 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어 인출
3. 인출한 명령어를 MBR에 저장
4. <u>다음 명령어를 인출하기 위해 PC값 증가</u>
5. MBR에 저장된 내용을 IR에 전달

```assembly
T0 : MAR ← PC
T1 : MBR ← M[MAR], PC ← PC+1
T2 : IR ← MBR
```

###### Fetch 이후 Execute

- PC 증가할 필요 X
- IR에 MBR의 값이 이미 저장되어있는 상태
- AC에 MBR를 더해주기만 하면 됨

``` assembly
T0 : MAR ← IR(Addr)
T1 : MBR ← M[MAR]
T2 : AC ← AC + MBR
```

### 캐시 메모리(Cache Memory)

속도가 빠른 장치와 느린 장치에서 <u>속도 차이에 따른 병목 현상을 줄이기 위한</u> 메모리

Ex) CPU 코어 - 메모리 사이의 병목 현상 완화, (웹 브라우저 캐시 파일) 하드디스크 - 웹페이지 사이 병목 현상 완화

- CPU가 주기억장치에 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤 다음에 이용할 때는 주기억장치가 아닌 캐시 메모리에서 먼저 가져오면서 속도를 향상시킨다.
- 장점: 속도가 향상됨 / 단점: 용량이 적고, 비용이 비쌈
- CPU에서는 2~3개의 캐시 메모리가 사용됨(L1, L2, L3)
  - 속도와 크기에 따라 분류
  - L1 캐시부터 먼저 사용
  - 듀얼 코어 프로세서의 경우 각 코어가 독립된 L1을 가지고, 두 코어가 L2를 공유함
    - L1 캐시가 128kb면 64kb에 명령어를 처리하기 직전의 명령어를 저장하고, 나머지 64kb에는 실행 후 명령어를 임시 저장
      - 명령어 세트로 구성, L cache - D cache
    - L1: CPU 내부에 존재, L2: CPU와 RAM 사이에 존재, L3: 보통 메인보드에 존재
    - 캐시 메모리 크기가 작은 이유: SRAM 가격이 매우 비쌈
    - 디스크 캐시: 주기억장치(RAM)와 보조기억장치(HDD) 사이에 존재하는 캐시

#### 작동 원리

- **시간 지역성**: 반복문에 사용되는 조건변수(for while에서 i, j)처럼 한번 참조된 데이터는 잠시 후 또 참조될 가능성이 높음
- **공간 지역성**: A[0], A[1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시 후 또 사용될 가능성이 높음
  - 이러한 참조 지역성을 최대한 활용하기 위해 해당 데이터뿐만 아니라, 옆 주소의 대에터도 가져와 같이 미래에 쓰일 것을 대비한다.
- CPU가 요청한 데이터가 캐시에 있으면 'Cache Hit', 없어서 DRAM에서 가져오면 'Cache Miss'

#### 캐시 미스의 경우 3가지

1. **Cold miss**
   - 해당 메모리 주소를 처음 불러서 나는 미스
2. **Conflict miss**
   - 캐시 메모리에 두 데이터를 저장해야 하는데, 두 데이터가 같은 캐시 메모리 주소에 할당되어 있어서 나는 미스(direct mapped cache에서 주로 발생)
   - Ex) 항상 핸드폰과 열쇠를 오른쪽 주머니(캐시)에 넣고 다니는데, 잠깐 친구가 준 물건을 받느라 손에 들고 있던 핸드폰을 가방에 넣었음. 그 이후 핸드폰을 찾으려 오른쪽 주머니에서 찾는데 없는 상황
3. **Capacity miss**
   - 캐시 메모리의 공간이 부족해서 나는 미스
   - Conflit가 주소 할당 문제라면, Capacity는 공간 문제
   - 캐시 크기를 키워서 문제를 해결하려 하면 캐시 접근 속도가 느려지고 파워를 많이 먹는 단점이 생김

#### 구조 및 작동 방식

- **Direct Mapped Cache**

  DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식

  <img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201013220532221.png" alt="image-20201013220532221" style="zoom: 67%;" />

  - 가장 기본적인 구조
  - 캐시 메모리 = 인덱스 필드(000) + 태그 필드(01) + 데이터 필드
  - 장점: 간단하고 빠르다
  - 단점: Conflict miss가 발생(같은 색깔의 데이터를 동시에 사용해야 할 때 발생)

- **Fully Associative Cache**

  비어있는 캐시 메모리가 있으면 마음대로 주소를 저장하는 방식

  - 장점: 저장할 때 매우 간단하다
  - 단점: 찾을 때가 어렵다, 가격이 비싸다
    - 저장할 때의 조건이나 규칙이 없어서 특정 캐시 set 안에 있는 모든 블럭을 한번에 찾아 원하는 데이터가 있는지 검색해야 함.. 비효율적
    - CAM이라는 특수한 메모리 구조를 사용해야 하는데, 이게 비쌈

- **Set Associative Cache**

  Direct + Fully 방식

  - 특정 행을 지정하고, 그 행 안의 어떤 열이든 비어있을 때 저장하는 방식
  - Direct보다 검색 속도는 느리지만, 저장이 빠르고
  - Fully에 비해 저장이 느린 대신 검색이 빠르다

### 고정 소수점 & 부동 소수점

컴퓨터에서 실수롤 표현하는 두가지 방식

#### 고정 소수점(Fixed Point)

소수점이 찍힐 위치를 미리 정해놓고 소수를 표현하는 방식

- 정수 + 소수
- 장점: 실수를 정수와 소수부로 표현하여 단순
- 단점: 표현의 범위가 너무 적어서 활용하기 힘듦(정수부 15bit, 소수부 16bit)

#### 부동 소수점(Floating Point)

지수의 값에 따라 소수점이 움직이는 방식을 활용한 방식

- 가수 + 지수
- 장점: 표현할 수 있는 수의 범위가 넓어짐(현재 대부분 시스템에서 활용중)
- 단점: 오차가 발생할 수 있다(부동소수점으로 표현할 수 있는 방법이 매우 다양)

### 패리티 비트 & 해밍 코드

#### 패리티 비트

정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트

- 전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송
- 전체 비트에서 짝홀에 맞도록 비트를 정함
- Ex) 짝수 패리티(짝수로 맞춰야 한다)일 때 7비트 데이터가 1010001 이라면
  - 짝수를 맞춰주기 위해 1을 더해서 '1'1010001 (맨 앞이 패리티비트인 경우)

#### 해밍 코드

데이터 전송 시 1비트의 에러를 정정할 수 있는 자기 오류 정정 코드

- 패리티비트를 보고, 1비트에 대한 오류를 정정할 곳을 찾아 수정할 수 있음
- 패리티비트는 오류를 검출하기만 할 뿐, 수정하지는 않으므로 해밍 코드 활용
- 방법
  - 2의 n승번째 자리(1,2,4)가 패리티 비트일 때
    - 각 자리에 따라 확인하는 비트의 규칙이 정해져 있음
  - 3개의 패리티 비트가 짝수인지 홀수인지 기준으로 판별
  - Ex) 0011011, 짝수 패리티일 때 오류가 수정된 코드는?
    - 1번째 비트: 1, 3, 5, 7번째 비트 확인. 0101. 짝수(0)
    - 2번째 비트: 2, 3, 6, 7번째 비트 확인. 0111. 홀수(1)
    - 4번째 비트: 4, 5, 6, 7번째 비트 확인. 1011. 홀수(1)
    - 즉 4-2-1 순서대로 이으면 110. 이를 10진법으로 바꾸면 6이므로 6번째 비트를 수정하면 된다
    - 답: 00110'0'1

### ARM 프로세서

- 프로세서: 메모리에 저장된 명령어들을 실행하는 유한 상태 오토마톤
- ARM: Advanced RISC Machine
  - RISC: Reduced Instruction Set Computing
  - 단순한 명령 집합을 가진 프로세서가 복잡한 명령 집합을 가진 프로세서보다 훨씬 더 효율적이지 않을까? 로 탄생함
  - 명령 집합의 수가 적기 때문에 트랜지스터 수가 적고, 이를 통해 크기가 작고 전원 소모가 낮은 ARM CPU가 스마트폰, 태블릿PC와 같은 모바일 기기에 많이 사용됨
- ARM을 위해 설계된 프로세서는 오직 ARM 프로세서가 탑재된 기기에서만 실행 가능
  - ARM에서 실행되던 프로그램을 x86 프로세서에서 실행되도록 하려면 수정을 해야됨(그 반대도)
- 하지만 하나의 ARM 기기에 동작하는 OS는 다른 ARM 기반 기기에서도 잘 동작함
  - 덕분에 수많은 버전의 안드로이드가 탄생
  - HP나 블랙베리의 타블렛에도 안드로이드가 탑재될 가능성이 생김
- ARM을 만드는 기업들은 ARM을 통해 전력 소모를 줄이고 성능을 높이기 위해 설계를 개선하며 노력함

## Data Structure 자료구조

### 배열(Array)

#### 배열 회전 프로그램

##### 기본적인 회전 알고리즘

- temp를 활용해서 첫번째 인덱스 값을 저장 후 arr[0]~arr[n-1]을 각각 arr[1]~arr[n]의 값을 주고, arr[n]에 temp를 넣어준다.
- 원하는 회전 수(n) 만큼 이동 가능

```c++
void leftRotatebyOne(int arr[], int n){
    int temp = arr[0], i;
    for(i = 0; i < n-1; i++){
       arr[i] = arr[i+1];
    }
    arr[i] = temp;
}
```

##### 저글링 알고리즘

<img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201014134454531.png" alt="image-20201014134454531" style="zoom:67%;" />

- 최대공약수를 이용해 집합을 나누어 여러 요소를 한꺼번에 이동시킴
- Ex) arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} 에서 1,2,3을 옮기려 할 때
  - 12와 3의 최소공약수는 3
  - 인덱스를 3개씩 묶고 회전시킴
  - a) arr [] -> { **4** 2 3 **7** 5 6 **10** 8 9 **1** 11 12}
  - b) arr [] -> {4 **5** 3 7 **8** 6 10 **11** 9 1 **2** 12}
  - c) arr [] -> {4 5 **6** 7 8 **9** 10 11 **12** 1 2 **3** }

```c++
void leftRotate(int arr[], int d, int n) 
{ 
    for (int i = 0; i < gcd(d, n); i++) { 
       
        int temp = arr[i]; 
        int j = i; 
  
        while (1) { 
            int k = j + d; 
            if (k >= n) 
                k = k - n; 
  
            if (k == i) 
                break; 
  
            arr[j] = arr[k]; 
            j = k; 
        } 
        arr[j] = temp; 
    } 
} 
```

##### 역전 알고리즘

- 회전시키는 수(피벗)에 대해 구간을 나누어 reverse로 구현

1. d=2라면 1,2 / 3,4,5,6,7 로 구간을 나누고
2. 첫번째 구간을 reverse: 2,1
3. 두번째 구간을 reverse: 7,6,5,4,3
4. 합치면 2,1,7,6,5,4,3
5. 합친 배열을 reverse: 3,4,5,6,7,1,2

```c++
void reverseArr(int arr[], int start, int end){
    while (start < end){
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;

        start++;
        end--;
    }
}

void rotateLeft(int arr[], int d, int n){
	reverseArr(arr, 0, d-1);
	reverseArr(arr, d, n-1);
	reverseArr(arr, 0, n-1);
}
```

#### 배열의 특정 최대 합 구하기

- arr가 있을 때, arr를 회전하면서 i*arr[i]의 합이 가장 큰 경우를 찾기
- Ex) arr[] = {1, 20, 2, 10}일 때 2번 회전해서 2\*0 + 10\*1 + 1\*2 + 20\*3 = 72가 최대
-  접근 방법
  - 회전 횟수에 따라 R0 = 0\*arr[0] + 1\*arr[1] +...+ (n-1)\*arr[n-1]
  - R1 = 0\*arr[n-1] + 1\*arr[0] +...+ (n-1)\*arr[n-2]
  - R1 - R0 = arr[0] + arr[1] + ... + arr[n-2] - (n-1)\*arr[n-1]
  - R2 - R1 = arr[0] + arr[1] + ... + arr[n-3] - (n-1)\*arr[n-2] + arr[n-1]
  - 즉, Rj - Rj-1 = arrSum - n \* arr[n-j] 이라는 규칙을 찾을 수 있다.
  - R0부터 구하고, 차이를 이용해서 비교하고 최댓값 갱신하면 됨

#### 특정 배열을 arr[i] = i로 재배열 하기

..?

### 연결 리스트(Linked List)

연속적인 메모리 위치에 저장되지 않는 선형 데이터 구조

- 포인터를 사용해서 연결

- 각 노드는 **데이터 필드**와 **다음 노드에 대한 참조**를 포함하는 노드로 구성

  ```c++
  // A linked list node 
  struct Node 
  { 
    int data; 
    struct Node *next;
  }; 
  ```

- Linked List를 사용하는 이유

  - 배열은 비슷한 유형의 선형 데이터를 저장하는데 사용할 수 있지만, 제한 사항이 있음..
    - 배열이 크기가 고정되어 있어 미리 요소 수에 대해 할당을 받아야 함
    - 새로운 요소를 삽입하는 것이 비용이 많이 듦(공간을 만들고, 기존 요소 전부 이동)

- 장점

  - 동적 크기
  - 삽입/삭제 용이

- 단점

  - 임의의 노드에 액세스가 안됨.. 첫번째 노드부터 순차적으로 요소에 액세스해야 함. (binary search도 불가능)
  - 포인터의 여분 메모리 공간이 목록의 각 요소에 필요???

#### Single Linked List(Java)

```java
class LinkedList {
    
    Node head;

    static class Node {
        int data;
        Node next;
        Node(int d) { // 생성자
            data = d; next = null;
        }
    }

    public void printList() 
    { 
        Node n = head; 
        while (n != null) 
        { 
            System.out.print(n.data+" "); 
            n = n.next; 
        } 
    }

    public static void main(String[] args){

        LinkedList llist = new LinkedList();

        llist.head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);
    
        llist.head.next = second; // 첫번째 노드에 두번째 노드 연결
        second.next = third; // 두번째 노드에 세번째 노드 연결
        
        llist.printList(); 
    }
}
```

#### 노드 추가(C)

- 앞쪽에 노드 추가

```c
void push(struct Node** head_ref, int new_data){
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));

    new_node->data = new_data;

    new_node->next = (*head_ref);

    (*head_ref) = new_node;
}
```

- 특정 노드 다음에 추가

```c
void insertAfter(struct Node* prev_node, int new_data){
    if (prev_node == NULL){
        printf("이전 노드가 NULL이 아니어야 합니다.");
        return;
    }

    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));

    new_node->data = new_data;
    new_node->next = prev_node->next;

    prev_node->next = new_node;
}
```

- 끝쪽에 노드 추가

```c
void append(struct Node** head_ref, int new_data){
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));

    struct Node* last = *head_ref;

    new_node->data = new_data;

    new_node->next = NULL;

    if (*head_ref == NULL){
        *head_ref = new_node;
        return;
    }

    while(last->next != NULL){
        last = last->next;
    }

    last->next = new_node;
    return;
}
```

### Array & ArrayList & LinkedList

#### 개요

<img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201014172241120.png" alt="image-20201014172241120" style="zoom:67%;" />

- **Array**: <u>index</u>로 빠르게 값을 찾는 것이 가능
- **LinkedList**: 데이터의 <u>삽입 및 삭제가 빠름</u>
- **ArrayList**: 데이터를 <u>찾는데 빠르지만</u>, <u>삽입 및 삭제가 느림</u>

> **상황에 맞는 자료구조를 잘 선택하는 것이 중요!**

#### Array(배열)

- 선언할 때 크기와 데이터 타입을 지정해야 함
- 즉, 메모리 공간에 <u>할당할 사이즈를 미리 정해놓고</u> 사용하는 자료구조
- 장점
  - index가 존재하므로 검색에 편하다
- 단점
  - 계속 데이터가 늘어날 때, 최대 사이즈를 알 수 없을 때, 중간에 데이터를 삽입/삭제할 때 비효율적!!!
    - 특정 index 값에 새로운 값을 넣으려면 원래 값을 뒤로 밀어내고 해당 index에 덮어씌워야 함..

#### List

- Array의 단점을 보완하기 위해 나옴
- <u>크기를 정해주지 않아도 됨!</u>
  - 대신 array는 index가 중요했다면, list에서는 <u>순서</u>가 중요!
- 장점
  - 크기가 정해져있지 않으므로 중간에 데이터를 추가/삭제하더라도 괜찮다.
  - index를 가지고 있으므로 검색도 빠르다
- 단점
  - 중간에 데이터를 추가/삭제할 때 시간이 오래 걸림
    - 더하거나 뺄 때 줄줄이 당겨지거나 밀려나는데 이때 연산이 추가되고, 메모리 또한 낭비된다.

#### LinkedList

- **한 노드에 연결될 노드의 포인터 위치를 가리키는 방식**
- 단일(뒤 노드만 가리킴), 다중(앞뒤 노드 모두 가리킴) 등 여러가지 존재
- 장점
  - 데이터를 중간에 삽입/삭제할 때 전체를 돌지 않아도 이전 값과 다음 값이 가리켰던 주소 값만 수정하고 연결시켜주면 되므로 빠르다.
- 단점
  - List의 k번째 값을 찾는 것은 비효율적임..
    - Array나 ArrayList의 경우 index를 갖고 있어 검색이 빠르지만, LinkedList는 처음부터 순차검색해야 하므로 시간이 더 걸린다..

### 스택 & 큐

#### 스택(Stack)

- 입력과 출력이 같은 한 곳(방향)으로 제한됨

- LIFO(Last In First Out, 후입선출): 늦게 들어온 원소가 먼저 나옴
- 사용 예) 함수의 call stack, 문자열 역순 출력, 연산자 후위표기법, DFS

##### 구현

- 스택 포인터(SP)

  - push와 pop할 때 해당 위치를 기억하는 변수
  - 처음에는 -1로 초기화
  - 마지막 원소의 위치를 기억하는듯..

  ```java
  private int sp = -1;
  ```

- push

  ```java
  public void push(Object o) {
      if(isFull(o)) { // 스택 포인터가 최대 크기와 같으면 return
          return;
      }
      
      stack[++sp] = o; // 아니면 스택의 최상위 위치에 값을 넣음
  }
  ```

- pop

  ```java
  public Object pop() {
      if(isEmpty(sp)) { // 스택 포인터가 0이 되면 null로 return
          return null;
      }
      
      Object o = stack[sp--]; // 아닌 경우 스택의 최상위 위치의 값을 꺼내오고, 스택 포인터의 값이 하나 내려감
      return o;
      
  }
  ```

- isEmpty

  ```java
  private boolean isEmpty(int sp) {
      return sp == -1 ? true : false; // sp가 초기화값과 같다면 true, 아니면 false
  }
  ```

- isFull

  ```java
  private boolean isFull(int sp) {
      return sp + 1 == MAX_SIZE ? true : false; // sp+1 값이 MAX_SIZE와 같으면 true, 아니면 false
  }
  ```

#### 동적 배열 스택

- 위처럼 구현하면 스택에는 MAX_SIZE라는 최대 크기가 정해짐
- 최대 크기가 없는 스택이 동적 배열 스택!

##### arraycopy(동적 배열)를 활용한 구현

```java
public void push(Object o) {
    
    if(isFull(sp)) { // 스택 포인터가 최대 크기에 도달한 경우
        Object[] arr = new Object[MAX_SIZE * 2]; // 2배 크기의 새로운 배열을 할당
        System.arraycopy(stack, 0, arr, 0, MAX_SIZE); // 값 복사
        stack = arr; // 참조값 할당
        MAX_SIZE *= 2; // MAX_SIZE 2배로 증가
    }
    
    stack[sp++] = o;
}
```

##### LinkedList를 활용한 구현

```java
public class Node {
    public int data;
    public Node next;

    public Node() {
    }

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class Stack {
    private Node head; // 제일 "아래" 노드. stack[0] 이라서 head인듯
    private Node top; // 제일 위 노드

    public Stack() {
        head = top = null;
    }

    private Node createNode(int data) {
        return new Node(data);
    }

    private boolean isEmpty() {
        return top == null ? true : false;
    }

    public void push(int data) {
        if (isEmpty()) { // 스택이 비어있다면
            head = createNode(data);
            top = head;
        }
        else { //스택이 비어있지 않다면 마지막 위치를 찾아 새 노드를 연결시킨다.
            Node pointer = head;

            while (pointer.next != null)
                pointer = pointer.next;

            pointer.next = createNode(data);
            top = pointer.next;
        }
    }

    public int pop() {
        int popData;
        if (!isEmpty()) { // 스택이 비어있지 않다면!! => 데이터가 있다면!!
            popData = top.data; // pop될 데이터를 미리 받아놓는다.
            Node pointer = head; // 현재 위치를 확인할 임시 노드 포인터

            if (head == top) // 데이터가 하나라면
                head = top = null;
            else { // 데이터가 2개 이상이라면
                while (pointer.next != top) // top을 가리키는 노드를 찾는다.
                    pointer = pointer.next;

                pointer.next = null; // 마지막 노드의 연결을 끊는다.
                top = pointer; // top을 이동시킨다.
            }
            return popData;
        }
        return -1; // -1은 데이터가 없다는 의미로 지정해둠.
    }
}
```

#### 큐(Queue)

- 입력과 출력이 서로 다른 한 곳(rear, front)으로 제한됨

- FIFO(First In First Out, 후입선출): 먼저 들어온 원소가 먼저 나옴
- 사용 예) 버퍼, BFS
- 큐의 가장 첫 원소를 front, 가장 끝 원소를 rear로 부름
- 큐에서는 원소가 rear로 들어와 front로 빠진다
- 가장 첫 원소와 끝 원소에만 접근 가능

##### 구현

- 기본값

  ```java
  private int size = 0; 
  // 데이터를 넣고 뺄 때 해당 값의 위치를 기억하기 위해 필요
  private int rear = -1; // enQueue할 위치 기억
  private int front = -1; // deQueue할 위치 기억
  
  Queue(int size) { 
      this.size = size;
      this.queue = new Object[size];
  }
  ```

- enQueue

  ```java
  public void enQueue(Object o) {
      
      if(isFull()) { // 큐가 가득 찼다면 overflow. return
          return;
      }
      
      queue[++rear] = o; // 아니면 rear+1에 값을 넣음
  }
  ```

- deQueue

  ```java
  public Object deQueue(Object o) {
      
      if(isEmpty()) { // 큐가 비어있다면 underflow. return
          return null;
      }
      
      Object o = queue[front]; // front에 위치한 값을 꺼낸 후
      queue[front++] = null; // 해당 위치의 값은 null로 채우고 front 위치를 하나 뒤로 보냄
      return o;
  }
  ```

- isEmpty

  ```java
  public boolean isEmpty() {
      return front == rear;
  }
  ```

- isFull

  ```java
  public boolean isFull() {
      return (rear == queueSize-1);
  }
  ```

그러나 일반 큐는 큐에 빈 메모리가 남아있어도 

#### 원형 큐(Circular Queue)



#### 연결리스트 큐

### 힙(Heap)

### 이진 탐색 트리

### 해시(Hash)

### 트라이(Trie)

### B Tree & B+ Tree

## Operating System 운영체제

## Database 데이터베이스

## Network 네트워크

## Software Engineering 소프트웨어 공학
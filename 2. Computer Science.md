# 2. Computer Science

## Computer Architecture 컴퓨터 구조

### 컴퓨터의 구성

하드웨어 + 소프트웨어

- 하드웨어: 컴퓨터를 구성하는 기계적 장치
- 소프트웨어: 하드웨어의 동작을 지시하고 제어하는 **명령어의 집합**
  - 시스템 소프트웨어: 운영체제, 컴파일러
  - 응용 소프트웨어: 워드프로세서, 스프레드시트

#### 하드웨어

<img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201013190232322.png" alt="image-20201013190232322" style="zoom: 67%;" />

중앙처리장치 + 기억장치 + 입출력장치

- 시스템 버스로 연결되어 있음
  - 데이터와 명령 제어 신호를 각 장치로 실어나르는 역할

##### 중앙처리장치(CPU)

산술논리연산장치(ALU) + 제어장치 + 레지스터

- 컴퓨터의 두뇌에 해당하는 부분
- 주기억장치에서 명령어와 데이터를 읽어와 처리, 명령어의 수행 순서 제어
- **ALU**: 비교와 연산 담당
- **제어장치**: 명령어의 해석/실행 담당
- **레지스터**: 속도가 빠른 데이터 기억 장소

##### 기억장치

주기억장치 + 보조기억장치

- 프로그램, 데이터, 연산 중간 결과를 저장하는 장치
- **주기억장치**
  - Ex) RAM, ROM
  - 실행중인 프로그램과 같은 <u>프로그램에 필요한 데이터를 일시적으로 저장</u>
- **보조기억장치**
  - Ex) HDD
  - 주기억장치보다 <u>느리지만</u> 많은 자료를 <u>영구적으로 보관</u>할 수 있음

##### 입출력장치

입력장치 + 출력장치

- **입력장치**: 컴퓨터 내부로 자료 입력(Ex. 키보드, 마우스, ...)
- **출력장치**: 컴퓨터 외부로 자료 표현(Ex. 프린터, 모니터, ...)

#### 시스템 버스

하드웨어 구성요소를 <u>물리적으로 연결</u>하는 선

##### 데이터 버스

<u>중앙처리장치</u>와 <u>기타 장치</u>(기억장치, 입출력장치) 사이에서 데이터 전달

- <u>양방향</u> 버스

##### 주소 버스

데이터를 정확하게 나르기 위해서 <u>기억장치의 주소를 전달</u>하는 통로

- 중앙처리장치 → 주기억장치, 입출력장치(<u>단방향</u> 버스)

##### 제어 버스

중앙처리장치가 기타 장치에 제어 신호를 전달하는 통로

- 데이터 버스와 주소 버스는 모든 장치에 공유되므로 이를 제어하는 수단

- 읽기, 쓰기 모두 수행(<u>양방향</u> 버스)
- 제어 신호 종류: 기억장치 읽기 및 쓰기, 버스 요청 및 승인, 인터럽트 요청 및 승인, 클락, 리셋, ...

#### 컴퓨터의 데이터 처리

읽고 처리한 뒤 저장 READ → PROCESS → WRITE

- 이 과정에서 끊임없이 주기억장치(RAM)과 소통
- 운영체제가 64bit라면 CPU는 RAM으로부터 데이트를 한번에 64bit씩 읽어옴 

### 중앙처리장치(CPU) 작동 원리

#### 각 장치의 특징 및 역할

##### 연산 장치(ALU)

- 산술 연산과 논리 연산 수행
- 연산에 필요한 데이터를 레지스터에서 가져오고, 연산 결과를 다시 레지스터로 보냄

##### 제어 장치

- 명령어를 순서대로 실행할 수 있도록 제어
- 주기억장치에서 명령어를 꺼내 해독하고, 그 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄
- 장치들이 보낸 신호를 받아 다음에 수행할 동작을 결정

##### 레지스터

- 고속 기억장치
- 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장
- CPU 종류에 따라 사용할 수 있는 레지스터 갯수와 크기가 다름
- 범용 레지스터: 연산에 필요한 데이터나 연산 결과를 임시로 저장
- 특수목적 레지스터: 특별한 용도로 사용하는 레지스터
  - MAR(메모리 주소 레지스터): <u>읽기/쓰기 연산을 수행할 주기억장치 주소</u> 저장
  - PC(프로그램 카운터): <u>다음에 수행할 명령어 주소</u> 저장
  - IR(명령어 레지스터): <u>현재 실행중인 명령어</u> 저장
  - MBR(메모리 버퍼 레지스터): <u>주기억장치에서 읽어온 데이터 또는 주기억장치에 저장할 데이터</u>를 임시로 저장
  - AC(누산기): <u>연산 결과를 임시로</u> 저장

#### CPU의 동작 과정

1. 주기억장치: 입력장치에서 입력받은 데이터 or 보조기억장치에 저장된 프로그램을 읽어옴
2. CPU: 프로그램을 실행하기 위해 주기억장치에 저장된 명령어와 데이터를 읽어와 처리. 그 결과를 다시 주기억장치에 저장
3. 주기억장치: 처리 결과를 보조기억장치에 저장하거나 출력장치로 보냄
4. 제어장치: 1~3 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어

#### 명령어 세트

CPU가 실행할 명령어의 집합, 연산 코드(Operation Code) + 피연산자(Operand)로 이루어짐

- 연산 코드: 실행할 연산
  - 연산, 제어, 데이터 전달, 입출력 기능
- 피연산자: 데이터 or 저장 위치
  - 주소, 숫자/문자, 논리 데이터 등 저장
- CPU는 프로그램을 실행하기 위해 '주기억장치에서 명령어를 순차적으로 인출하여 해독하고 실행하는 과정'을 반복
- 명령어 사이클: CPU가 주기억장치에서 한번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동
  - Fetch / Execute / Indirect / Indirect 사이클로 나누어짐
  - 주기억장치의 지정된 주소에서 하나의 명령어를 가져오고, Execute 사이클에서는 명령어를 실행함. 하나의 명령어 실행이 완료되면 그 다음 명령어에 대한 Fetch 사이클 시작

##### Fetch 사이클과 Execute 사이클에 의한 명령어 처리 과정

###### Fetch

1. PC에 저장된 주소를 MAR로 전달
2. 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어 인출
3. 인출한 명령어를 MBR에 저장
4. <u>다음 명령어를 인출하기 위해 PC값 증가</u>
5. MBR에 저장된 내용을 IR에 전달

```assembly
T0 : MAR ← PC
T1 : MBR ← M[MAR], PC ← PC+1
T2 : IR ← MBR
```

###### Fetch 이후 Execute

- PC 증가할 필요 X
- IR에 MBR의 값이 이미 저장되어있는 상태
- AC에 MBR를 더해주기만 하면 됨

``` assembly
T0 : MAR ← IR(Addr)
T1 : MBR ← M[MAR]
T2 : AC ← AC + MBR
```

### 캐시 메모리(Cache Memory)

속도가 빠른 장치와 느린 장치에서 <u>속도 차이에 따른 병목 현상을 줄이기 위한</u> 메모리

Ex) CPU 코어 - 메모리 사이의 병목 현상 완화, (웹 브라우저 캐시 파일) 하드디스크 - 웹페이지 사이 병목 현상 완화

- CPU가 주기억장치에 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤 다음에 이용할 때는 주기억장치가 아닌 캐시 메모리에서 먼저 가져오면서 속도를 향상시킨다.
- 장점: 속도가 향상됨 / 단점: 용량이 적고, 비용이 비쌈
- CPU에서는 2~3개의 캐시 메모리가 사용됨(L1, L2, L3)
  - 속도와 크기에 따라 분류
  - L1 캐시부터 먼저 사용
  - 듀얼 코어 프로세서의 경우 각 코어가 독립된 L1을 가지고, 두 코어가 L2를 공유함
    - L1 캐시가 128kb면 64kb에 명령어를 처리하기 직전의 명령어를 저장하고, 나머지 64kb에는 실행 후 명령어를 임시 저장
      - 명령어 세트로 구성, L cache - D cache
    - L1: CPU 내부에 존재, L2: CPU와 RAM 사이에 존재, L3: 보통 메인보드에 존재
    - 캐시 메모리 크기가 작은 이유: SRAM 가격이 매우 비쌈
    - 디스크 캐시: 주기억장치(RAM)와 보조기억장치(HDD) 사이에 존재하는 캐시

#### 작동 원리

- **시간 지역성**: 반복문에 사용되는 조건변수(for while에서 i, j)처럼 한번 참조된 데이터는 잠시 후 또 참조될 가능성이 높음
- **공간 지역성**: A[0], A[1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시 후 또 사용될 가능성이 높음
  - 이러한 참조 지역성을 최대한 활용하기 위해 해당 데이터뿐만 아니라, 옆 주소의 대에터도 가져와 같이 미래에 쓰일 것을 대비한다.
- CPU가 요청한 데이터가 캐시에 있으면 'Cache Hit', 없어서 DRAM에서 가져오면 'Cache Miss'

#### 캐시 미스의 경우 3가지

1. **Cold miss**
   - 해당 메모리 주소를 처음 불러서 나는 미스
2. **Conflict miss**
   - 캐시 메모리에 두 데이터를 저장해야 하는데, 두 데이터가 같은 캐시 메모리 주소에 할당되어 있어서 나는 미스(direct mapped cache에서 주로 발생)
   - Ex) 항상 핸드폰과 열쇠를 오른쪽 주머니(캐시)에 넣고 다니는데, 잠깐 친구가 준 물건을 받느라 손에 들고 있던 핸드폰을 가방에 넣었음. 그 이후 핸드폰을 찾으려 오른쪽 주머니에서 찾는데 없는 상황
3. **Capacity miss**
   - 캐시 메모리의 공간이 부족해서 나는 미스
   - Conflict가 주소 할당 문제라면, Capacity는 공간 문제
   - 캐시 크기를 키워서 문제를 해결하려 하면 캐시 접근 속도가 느려지고 파워를 많이 먹는 단점이 생김

#### 구조 및 작동 방식

- **Direct Mapped Cache**

  DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식

  <img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201013220532221.png" alt="image-20201013220532221" style="zoom: 67%;" />

  - 가장 기본적인 구조
  - 캐시 메모리 = 인덱스 필드(000) + 태그 필드(01) + 데이터 필드
  - 장점: 간단하고 빠르다
  - 단점: Conflict miss가 발생(같은 색깔의 데이터를 동시에 사용해야 할 때 발생)

- **Fully Associative Cache**

  비어있는 캐시 메모리가 있으면 마음대로 주소를 저장하는 방식

  - 장점: 저장할 때 매우 간단하다
  - 단점: 찾을 때가 어렵다, 가격이 비싸다
    - 저장할 때의 조건이나 규칙이 없어서 특정 캐시 set 안에 있는 모든 블럭을 한번에 찾아 원하는 데이터가 있는지 검색해야 함.. 비효율적
    - CAM이라는 특수한 메모리 구조를 사용해야 하는데, 이게 비쌈

- **Set Associative Cache**

  Direct + Fully 방식

  - 특정 행을 지정하고, 그 행 안의 어떤 열이든 비어있을 때 저장하는 방식
  - Direct보다 검색 속도는 느리지만, 저장이 빠르고
  - Fully에 비해 저장이 느린 대신 검색이 빠르다

### 고정 소수점 & 부동 소수점

컴퓨터에서 실수롤 표현하는 두가지 방식

#### 고정 소수점(Fixed Point)

소수점이 찍힐 위치를 미리 정해놓고 소수를 표현하는 방식

- 정수 + 소수
- 장점: 실수를 정수와 소수부로 표현하여 단순
- 단점: 표현의 범위가 너무 적어서 활용하기 힘듦(정수부 15bit, 소수부 16bit)

#### 부동 소수점(Floating Point)

지수의 값에 따라 소수점이 움직이는 방식을 활용한 방식

- 가수 + 지수
- 장점: 표현할 수 있는 수의 범위가 넓어짐(현재 대부분 시스템에서 활용중)
- 단점: 오차가 발생할 수 있다(부동소수점으로 표현할 수 있는 방법이 매우 다양)

### 패리티 비트 & 해밍 코드

#### 패리티 비트

정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트

- 전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송
- 전체 비트에서 짝홀에 맞도록 비트를 정함
- Ex) 짝수 패리티(짝수로 맞춰야 한다)일 때 7비트 데이터가 1010001 이라면
  - 짝수를 맞춰주기 위해 1을 더해서 '1'1010001 (맨 앞이 패리티비트인 경우)

#### 해밍 코드

데이터 전송 시 1비트의 에러를 정정할 수 있는 자기 오류 정정 코드

- 패리티비트를 보고, 1비트에 대한 오류를 정정할 곳을 찾아 수정할 수 있음
- 패리티비트는 오류를 검출하기만 할 뿐, 수정하지는 않으므로 해밍 코드 활용
- 방법
  - 2의 n승번째 자리(1,2,4)가 패리티 비트일 때
    - 각 자리에 따라 확인하는 비트의 규칙이 정해져 있음
  - 3개의 패리티 비트가 짝수인지 홀수인지 기준으로 판별
  - Ex) 0011011, 짝수 패리티일 때 오류가 수정된 코드는?
    - 1번째 비트: 1, 3, 5, 7번째 비트 확인. 0101. 짝수(0)
    - 2번째 비트: 2, 3, 6, 7번째 비트 확인. 0111. 홀수(1)
    - 4번째 비트: 4, 5, 6, 7번째 비트 확인. 1011. 홀수(1)
    - 즉 4-2-1 순서대로 이으면 110. 이를 10진법으로 바꾸면 6이므로 6번째 비트를 수정하면 된다
    - 답: 00110'0'1

### ARM 프로세서

- 프로세서: 메모리에 저장된 명령어들을 실행하는 유한 상태 오토마톤
- ARM: Advanced RISC Machine
  - RISC: Reduced Instruction Set Computing
  - 단순한 명령 집합을 가진 프로세서가 복잡한 명령 집합을 가진 프로세서보다 훨씬 더 효율적이지 않을까? 로 탄생함
  - 명령 집합의 수가 적기 때문에 트랜지스터 수가 적고, 이를 통해 크기가 작고 전원 소모가 낮은 ARM CPU가 스마트폰, 태블릿PC와 같은 모바일 기기에 많이 사용됨
- ARM을 위해 설계된 프로세서는 오직 ARM 프로세서가 탑재된 기기에서만 실행 가능
  - ARM에서 실행되던 프로그램을 x86 프로세서에서 실행되도록 하려면 수정을 해야됨(그 반대도)
- 하지만 하나의 ARM 기기에 동작하는 OS는 다른 ARM 기반 기기에서도 잘 동작함
  - 덕분에 수많은 버전의 안드로이드가 탄생
  - HP나 블랙베리의 타블렛에도 안드로이드가 탑재될 가능성이 생김
- ARM을 만드는 기업들은 ARM을 통해 전력 소모를 줄이고 성능을 높이기 위해 설계를 개선하며 노력함

## Data Structure 자료구조

### 배열(Array)

#### 배열 회전 프로그램

##### 기본적인 회전 알고리즘

- temp를 활용해서 첫번째 인덱스 값을 저장 후 arr[0]~arr[n-1]을 각각 arr[1]~arr[n]의 값을 주고, arr[n]에 temp를 넣어준다.
- 원하는 회전 수(n) 만큼 이동 가능

```c++
void leftRotatebyOne(int arr[], int n){
    int temp = arr[0], i;
    for(i = 0; i < n-1; i++){
       arr[i] = arr[i+1];
    }
    arr[i] = temp;
}
```

##### 저글링 알고리즘

<img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201014134454531.png" alt="image-20201014134454531" style="zoom:67%;" />

- 최대공약수를 이용해 집합을 나누어 여러 요소를 한꺼번에 이동시킴
- Ex) arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} 에서 1,2,3을 옮기려 할 때
  - 12와 3의 최소공약수는 3
  - 인덱스를 3개씩 묶고 회전시킴
  - a) arr [] -> { **4** 2 3 **7** 5 6 **10** 8 9 **1** 11 12}
  - b) arr [] -> {4 **5** 3 7 **8** 6 10 **11** 9 1 **2** 12}
  - c) arr [] -> {4 5 **6** 7 8 **9** 10 11 **12** 1 2 **3** }

```c++
void leftRotate(int arr[], int d, int n) 
{ 
    for (int i = 0; i < gcd(d, n); i++) { 
       
        int temp = arr[i]; 
        int j = i; 
  
        while (1) { 
            int k = j + d; 
            if (k >= n) 
                k = k - n; 
  
            if (k == i) 
                break; 
  
            arr[j] = arr[k]; 
            j = k; 
        } 
        arr[j] = temp; 
    } 
} 
```

##### 역전 알고리즘

- 회전시키는 수(피벗)에 대해 구간을 나누어 reverse로 구현

1. d=2라면 1,2 / 3,4,5,6,7 로 구간을 나누고
2. 첫번째 구간을 reverse: 2,1
3. 두번째 구간을 reverse: 7,6,5,4,3
4. 합치면 2,1,7,6,5,4,3
5. 합친 배열을 reverse: 3,4,5,6,7,1,2

```c++
void reverseArr(int arr[], int start, int end){
    while (start < end){
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;

        start++;
        end--;
    }
}

void rotateLeft(int arr[], int d, int n){
	reverseArr(arr, 0, d-1);
	reverseArr(arr, d, n-1);
	reverseArr(arr, 0, n-1);
}
```

#### 배열의 특정 최대 합 구하기

- arr가 있을 때, arr를 회전하면서 i*arr[i]의 합이 가장 큰 경우를 찾기
- Ex) arr[] = {1, 20, 2, 10}일 때 2번 회전해서 2\*0 + 10\*1 + 1\*2 + 20\*3 = 72가 최대
-  접근 방법
  - 회전 횟수에 따라 R0 = 0\*arr[0] + 1\*arr[1] +...+ (n-1)\*arr[n-1]
  - R1 = 0\*arr[n-1] + 1\*arr[0] +...+ (n-1)\*arr[n-2]
  - R1 - R0 = arr[0] + arr[1] + ... + arr[n-2] - (n-1)\*arr[n-1]
  - R2 - R1 = arr[0] + arr[1] + ... + arr[n-3] - (n-1)\*arr[n-2] + arr[n-1]
  - 즉, Rj - Rj-1 = arrSum - n \* arr[n-j] 이라는 규칙을 찾을 수 있다.
  - R0부터 구하고, 차이를 이용해서 비교하고 최댓값 갱신하면 됨

#### 특정 배열을 arr[i] = i로 재배열 하기

..?

### 연결 리스트(Linked List)

연속적인 메모리 위치에 저장되지 않는 선형 데이터 구조

- 포인터를 사용해서 연결

- 각 노드는 **데이터 필드**와 **다음 노드에 대한 참조**를 포함하는 노드로 구성

  ```c++
  // A linked list node 
  struct Node 
  { 
    int data; 
    struct Node *next;
  }; 
  ```

- Linked List를 사용하는 이유

  - 배열은 비슷한 유형의 선형 데이터를 저장하는데 사용할 수 있지만, 제한 사항이 있음..
    - 배열이 크기가 고정되어 있어 미리 요소 수에 대해 할당을 받아야 함
    - 새로운 요소를 삽입하는 것이 비용이 많이 듦(공간을 만들고, 기존 요소 전부 이동)

- 장점

  - 동적 크기
  - 삽입/삭제 용이

- 단점

  - 임의의 노드에 액세스가 안됨.. 첫번째 노드부터 순차적으로 요소에 액세스해야 함. (binary search도 불가능)
  - 포인터의 여분 메모리 공간이 목록의 각 요소에 필요???

#### Single Linked List(Java)

```java
class LinkedList {
    
    Node head;

    static class Node {
        int data;
        Node next;
        Node(int d) { // 생성자
            data = d; next = null;
        }
    }

    public void printList() 
    { 
        Node n = head; 
        while (n != null) 
        { 
            System.out.print(n.data+" "); 
            n = n.next; 
        } 
    }

    public static void main(String[] args){

        LinkedList llist = new LinkedList();

        llist.head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);
    
        llist.head.next = second; // 첫번째 노드에 두번째 노드 연결
        second.next = third; // 두번째 노드에 세번째 노드 연결
        
        llist.printList(); 
    }
}
```

#### 노드 추가(C)

- 앞쪽에 노드 추가

```c
void push(struct Node** head_ref, int new_data){
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));

    new_node->data = new_data;

    new_node->next = (*head_ref);

    (*head_ref) = new_node;
}
```

- 특정 노드 다음에 추가

```c
void insertAfter(struct Node* prev_node, int new_data){
    if (prev_node == NULL){
        printf("이전 노드가 NULL이 아니어야 합니다.");
        return;
    }

    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));

    new_node->data = new_data;
    new_node->next = prev_node->next;

    prev_node->next = new_node;
}
```

- 끝쪽에 노드 추가

```c
void append(struct Node** head_ref, int new_data){
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));

    struct Node* last = *head_ref;

    new_node->data = new_data;

    new_node->next = NULL;

    if (*head_ref == NULL){
        *head_ref = new_node;
        return;
    }

    while(last->next != NULL){
        last = last->next;
    }

    last->next = new_node;
    return;
}
```

### Array & ArrayList & LinkedList

#### 개요

<img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201014172241120.png" alt="image-20201014172241120" style="zoom:67%;" />

- **Array**: <u>index</u>로 빠르게 값을 찾는 것이 가능
- **LinkedList**: 데이터의 <u>삽입 및 삭제가 빠름</u>
- **ArrayList**: 데이터를 <u>찾는데 빠르지만</u>, <u>삽입 및 삭제가 느림</u>

> **상황에 맞는 자료구조를 잘 선택하는 것이 중요!**

#### Array(배열)

- 선언할 때 크기와 데이터 타입을 지정해야 함
- 즉, 메모리 공간에 <u>할당할 사이즈를 미리 정해놓고</u> 사용하는 자료구조
- 장점
  - index가 존재하므로 검색에 편하다
- 단점
  - 계속 데이터가 늘어날 때, 최대 사이즈를 알 수 없을 때, 중간에 데이터를 삽입/삭제할 때 비효율적!!!
    - 특정 index 값에 새로운 값을 넣으려면 원래 값을 뒤로 밀어내고 해당 index에 덮어씌워야 함..

#### List

- Array의 단점을 보완하기 위해 나옴
- <u>크기를 정해주지 않아도 됨!</u>
  - 대신 array는 index가 중요했다면, list에서는 <u>순서</u>가 중요!
- 장점
  - 크기가 정해져있지 않으므로 중간에 데이터를 추가/삭제하더라도 괜찮다.
  - index를 가지고 있으므로 검색도 빠르다
- 단점
  - 중간에 데이터를 추가/삭제할 때 시간이 오래 걸림
    - 더하거나 뺄 때 줄줄이 당겨지거나 밀려나는데 이때 연산이 추가되고, 메모리 또한 낭비된다.

#### LinkedList

- **한 노드에 연결될 노드의 포인터 위치를 가리키는 방식**
- 단일(뒤 노드만 가리킴), 다중(앞뒤 노드 모두 가리킴) 등 여러가지 존재
- 장점
  - 데이터를 중간에 삽입/삭제할 때 전체를 돌지 않아도 이전 값과 다음 값이 가리켰던 주소 값만 수정하고 연결시켜주면 되므로 빠르다.
- 단점
  - List의 k번째 값을 찾는 것은 비효율적임..
    - Array나 ArrayList의 경우 index를 갖고 있어 검색이 빠르지만, LinkedList는 처음부터 순차검색해야 하므로 시간이 더 걸린다..

### 스택 & 큐

#### 스택(Stack)

- 입력과 출력이 같은 한 곳(방향)으로 제한됨

- LIFO(Last In First Out, 후입선출): 늦게 들어온 원소가 먼저 나옴
- 사용 예) 함수의 call stack, 문자열 역순 출력, 연산자 후위표기법, DFS

##### 구현

- 스택 포인터(SP)

  - push와 pop할 때 해당 위치를 기억하는 변수
  - 처음에는 -1로 초기화
  - 마지막 원소의 위치를 기억하는듯..

  ```java
  private int sp = -1;
  ```

- push

  ```java
  public void push(Object o) {
      if (isFull(o)) { // 스택 포인터가 최대 크기와 같으면 return
          return;
      }
      
      stack[++sp] = o; // 아니면 스택의 최상위 위치에 값을 넣음
  }
  ```

- pop

  ```java
  public Object pop() {
      if (isEmpty(sp)) { // 스택 포인터가 0이 되면 null로 return
          return null;
      }
      
      Object o = stack[sp--]; // 아닌 경우 스택의 최상위 위치의 값을 꺼내오고, 스택 포인터의 값이 하나 내려감
      return o;
      
  }
  ```

- isEmpty

  ```java
  private boolean isEmpty(int sp) {
      return sp == -1 ? true : false; // sp가 초기화값과 같다면 true, 아니면 false
  }
  ```

- isFull

  ```java
  private boolean isFull(int sp) {
      return sp + 1 == MAX_SIZE ? true : false; // sp+1 값이 MAX_SIZE와 같으면 true, 아니면 false
  }
  ```

#### 동적 배열 스택

- 위처럼 구현하면 스택에는 MAX_SIZE라는 최대 크기가 정해짐
- 최대 크기가 없는 스택이 동적 배열 스택!

##### arraycopy(동적 배열)를 활용한 구현

```java
public void push(Object o) {
    
    if (isFull(sp)) { // 스택 포인터가 최대 크기에 도달한 경우
        Object[] arr = new Object[MAX_SIZE * 2]; // 2배 크기의 새로운 배열을 할당
        System.arraycopy(stack, 0, arr, 0, MAX_SIZE); // 값 복사
        stack = arr; // 참조값 할당
        MAX_SIZE *= 2; // MAX_SIZE 2배로 증가
    }
    
    stack[sp++] = o;
}
```

##### LinkedList를 활용한 구현

```java
public class Node {
    public int data;
    public Node next;

    public Node() {
    }

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class Stack {
    private Node head; // 제일 "아래" 노드. stack[0] 이라서 head인듯
    private Node top; // 제일 위 노드

    public Stack() {
        head = top = null;
    }

    private Node createNode(int data) {
        return new Node(data);
    }

    private boolean isEmpty() {
        return top == null ? true : false;
    }

    public void push(int data) {
        if (isEmpty()) { // 스택이 비어있다면
            head = createNode(data);
            top = head;
        }
        else { //스택이 비어있지 않다면 마지막 위치를 찾아 새 노드를 연결시킨다.
            Node pointer = head;

            while (pointer.next != null)
                pointer = pointer.next;

            pointer.next = createNode(data);
            top = pointer.next;
        }
    }

    public int pop() {
        int popData;
        if (!isEmpty()) { // 스택이 비어있지 않다면!! => 데이터가 있다면!!
            popData = top.data; // pop될 데이터를 미리 받아놓는다.
            Node pointer = head; // 현재 위치를 확인할 임시 노드 포인터

            if (head == top) // 데이터가 하나라면
                head = top = null;
            else { // 데이터가 2개 이상이라면
                while (pointer.next != top) // top을 가리키는 노드를 찾는다.
                    pointer = pointer.next;

                pointer.next = null; // 마지막 노드의 연결을 끊는다.
                top = pointer; // top을 이동시킨다.
            }
            return popData;
        }
        return -1; // -1은 데이터가 없다는 의미로 지정해둠.
    }
}
```

#### 큐(Queue)

- 입력과 출력이 서로 다른 한 곳(rear, front)으로 제한됨

- FIFO(First In First Out, 후입선출): 먼저 들어온 원소가 먼저 나옴
- 사용 예) 버퍼, BFS
- 큐의 가장 첫 원소를 front, 가장 끝 원소를 rear로 부름
- 큐에서는 원소가 rear로 들어와 front로 빠진다
- 가장 첫 원소와 끝 원소에만 접근 가능

##### 구현

- 기본값

  ```java
  private int size = 0; 
  // 데이터를 넣고 뺄 때 해당 값의 위치를 기억하기 위해 필요
  private int rear = -1; // enQueue할 위치 기억
  private int front = 0; // deQueue할 위치 기억
  
  Queue(int size) { 
      this.size = size;
      this.queue = new Object[size];
  }
  ```

- enQueue

  ```java
  public void enQueue(Object o) {
      
      if (isFull()) return;
      
      queue[++rear] = o; // 아니면 rear+1에 값을 넣음
  }
  ```
  
- deQueue

  ```java
  public Object deQueue() {
      
      if (isEmpty()) return null;
      
      Object o = queue[front++];
      return o;
  }
  ```
  
- isEmpty

  ```java
  public boolean isEmpty() {
      return front == rear+1;
  }
  ```

- isFull

  ```java
  public boolean isFull() {
      return (rear == queueSize-1);
  }
  ```

##### 단점

<img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201019151125822.png" alt="image-20201019151125822" style="zoom:50%;" />

- 일반 큐(선형 큐)의 경우 front, reat 모두 -1에서 시작하여 삽입과 삭제가 반복될 수록 두 변수 모두 계속 증가하게 된다.
- 이러한 과정이 반복되면 rear가 queue(크기 n)의 마지막 인덱스인 n-1에 도달하게 되는데, 이 경우 앞의 데이터가 비어있는 경우에도 rear == queueSize-1 이 되어 isFull()이 true가 된다.
- <u>즉, 앞이 비어있는 경우에도 큐가 꽉 찼다고 인식하게 됨!</u>

#### 원형 큐(Circular Queue)

- 논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 간주
  - 선형 큐의 단점을 보완
- <u>empty와 full을 쉽게 구분하기 위해 자리 하나를 항상 비워둠</u>
- **(index + 1) % size** 로 순환시킴

<img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201019163012570.png" alt="image-20201019163012570" style="zoom:67%;" />

##### 구현

- 기본값

  ```java
  private int size = 0; 
  private int rear = -1; 
  private int front = 0;
  
  Queue(int size) {
      this.size = ++size; // 한 자리 더 할당하고 빈 자리로 사용
      this.queue = new Object[size];
  }
  ```

- enQueue

  ```java
  public void enQueue(Object o) {
      
      if (isFull()) return;
      
      rear = (rear + 1) % size; // 더해주고 mod
      queue[rear] = o;
  }
  ```

- deQueue

  ```java
  public Object deQueue() {
      
      if (isEmpty()) return null;
      
      Object o = queue[front];
      front = (front + 1) % size;
      return o;
  }
  ```

- isEmpty

  <img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201019165452008.png" alt="image-20201019165452008" style="zoom:67%;" />

  ```java
  public boolean isEmpty() {
      return ((rear + 1) % size) == front;
  }
  ```

- isFull

  <img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201019165505212.png" alt="image-20201019165505212" style="zoom:67%;" />

  ```java
  public boolean isFull() {
      return ((rear + 2) % size) == front;
  }
  ```

##### 단점

- 메모리 공간에 대한 활용은 좋지만, 어쨌든 <u>배열로 구현</u>되어 있기 때문에 <u>큐의 크기가 제한됨!</u>

#### 연결리스트 큐

- LinkedList를 이용하여 큐를 구현하여 크기의 제한이 없고, 삽입 및 삭제가 편리
  - 원형 큐의 단점을 보완

##### 구현

- enQueue
  - 데이터 추가는 tail에 한다
  - 기존의 tail은 보관하고, 새로운 tail 생성
  - 큐가 비었으면 head = tail
  - 큐가 비어있지 않으면 기존 tail의 next에 새로 만든 tail을 설정

```java
public void enqueue(Object item) {
    Node oldlast = tail; // 기존의 tail 임시 저장
    tail = new Node; // 새로운 tail 생성
    tail.item = item;
    tail.next = null;
    
    if (isEmpty()) head = tail;
    else oldlast.next = tail;
}
```

- deQueue
  - 데이터 꺼내기는 head에서 한다
  - head의 데이터를 미리 저장해둠
  - head가 가리키는 값을 현재 head의 다음 노드로 설정
  - 저장해둔 데이터를 return

```java
public Object dequeue() {
    // 비어있으면
    if (isEmpty()) {
        tail = head;
        return null;
    }
    // 비어있지 않으면
    else {
        Object item = head.item; // 빼낼 현재 front 값 저장
        head = head.next; // front를 다음 노드로 설정
        return item;
    }
}
```

삽입은 tail, 제거는 head로.. O(1)에 가능!

### 힙(Heap)

우선순위 큐(Priority Queue)를 위해 만들어진 자료구조

- 우선순위 큐
  - 데이터들이 우선순위를 가지고, 우선순위가 높은 데이터가 먼저 나감
  - Ex) 시뮬레이션 시스템, 작업 스케줄링, 수치해석 계산
  - 배열, 연결리스트, 힙으로 구현이 가능한데 <u>힙으로 구현하는 것이 가장 효율적!</u>
    - 삽입, 삭제: O(log n)

##### 특징

- 완전 이진 트리의 일종
  - 여러 값 중 max와 min을 빠르게 찾아내도록 만들어진 자료구조
- 반 정렬 상태
  - max heap 기준으로 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다 정도로..
- 중복된 값 허용(이진 탐색 트리는 중복 허용 X..)
- 최대 힙(max heap, 루트 노드가 max인 이진트리), 최소 힙(min heap, 루트 노드가 min인 이진트리)

##### 구현(배열로 구현)

- 구현의 편의를 위해 index 0은 사용하지 않음
- 특정 노드의 인덱스가 i일 때
  - 왼쪽 자식은 2i
  - 오른쪽 자식은 2i+1
  - 부모 노드는 i/2
- 힙의 삽입(Max heap)
  1. 힙에 새로운 원소가 들어오면, 힙의 마지막 노드로 삽입
  2. 새로운 노드를 부모 노드들과 비교하며 교환

```java
void insert_max_heap(int x) {
    
    maxHeap[++heapSize] = x; 
    // 힙 크기를 하나 증가하고, 마지막 노드에 x를 넣음
    
    for( int i = heapSize; i > 1; i /= 2) {
        
        // 마지막 노드가 자신의 부모 노드보다 크면 swap
        if (maxHeap[i/2] < maxHeap[i])
            swap(i/2, i);
        else
            break;
    }
}
```

- 힙의 삭제(Max heap)
  1. 힙에서의 삭제는 루트 노드의 삭제를 의미
     - max heap의 경우 최대값, min heap의 경우 최소값을 삭제하는 셈
  2. 삭제된 루트 노드에 힙의 마지막 노드를 가져옴
  3. 루트 노드에 들어온 새 노드를 자식 노드들과 비교하며 교환
     - 이 때, 왼쪽 오른쪽 모든 노드와 swap이 가능할 경우 둘 중 더 큰 노드와 swap해야 함!!! 둘중 아무나 하면 힙의 의미가 깨질 수 있음.

```java
int delete_max_heap() {
    
    if (heapSize == 0) // 배열이 비어있으면 리턴
        return 0;
    
    int item = maxHeap[1]; // 루트 노드의 값을 저장
    maxHeap[1] = maxHeap[heapSize]; // 마지막 노드 값을 루트로 이동
    
    for(int i = 1; i*2 <= heapSize;) {
        
        // 새 루트 노드가 왼쪽 노드와 오른쪽 노드 이상이면 끝
        if (maxHeap[i] >= maxHeap[i*2] && maxHeap[i] >= maxHeap[i*2+1]) {
            break;
        }
        
        // 왼쪽 자식이 더 큰 경우 왼쪽 자식과 swap
        if (maxHeap[i*2] > maxHeap[i*2+1]) {
            swap(i, i*2);
            i = i*2;
        }
        
        // 오른쪽 자식이 더 큰 경우
        else {
            swap(i, i*2+1);
            i = i*2+1;
        }
    }
    
    return item;
    
}
```

### 이진 탐색 트리(Binary Search Tree)

<u>이진탐색</u>(**탐색 O(logN)**, 삽입 삭제 불가) + <u>연결리스트</u>(**삽입 삭제 O(1)**, 탐색 O(N))

<img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201119233027564.png" alt="image-20201119233027564" style="zoom:50%;" />

##### 특징

- 각 노드의 자식이 2개 이하
- 왼쪽 자식 < 부모 노드 < 오른쪽 자식
- 중복된 노드가 없어야 함
  - 중복을 허용하면 검색 속도가 느려짐..
  - 트리에 삽입하지 말고 노드에 count값을 가지게 하여 처리하는 것이 더 효율적
- 중위순회(inorder)로 읽으면 정렬된 순서대로 읽을 수 있음

##### 핵심 연산

- 검색

  ```java
  public boolean find(int id){
  	Node current = root;
      // O(h)
  	while (current != null){
  		//현재 노드와 찾는 값이 같으면
  		if (current.getData() == id){
  			return true;
  		}
          //찾는 값이 현재 노드보다 작으면
          else if (current.getData() > id){
  			current = current.getLeft();
  		}
          //찾는 값이 현재 노드보다 크면
          else {
  			current = current.getRight();
  		}
  	}
  	return false;
  }
  ```

- 삽입

  ```java
  public void insert(int id){
  	Node newNode = new Node(id);
  	if (root==null){
  		root = newNode;
  		return;
  	}
  	Node current = root;
  	Node parent = null;
      // O(h)
  	while (true){
  		parent = current;
  		if (id < current.getData()){				
  			current = current.getLeft();
  			if (current==null){
  				parent.setLeft(newNode);
  				return;
  			}
  		} 
          else {
  			current = current.getRight();
  			if (current==null){
  				parent.setRight(newNode);
  				return;
  			}
  		}
  	}
  }
  ```

- 삭제

  - 자식이 없는 leaf 노드일 때: 그냥 삭제
  - 자식이 1개인 노드일 때: 지워진 노드에 자식을 올린다
  - 자식이 2개인 노드일 때: 오른쪽 자식노드들 중 가장 작은 값 or 왼쪽 자식노드들 중 가장 큰 값을 올린다

  ```java
  public boolean delete(int id){
  	Node parent = root;
  	Node current = root;
  	boolean isLeftChild = false;
      // 지울 노드의 위치로 가는 과정 O(h)
  	while (current.getData()!= id){
  		parent = current;
  		if (current.getData() > id){
  			isLeftChild = true;
  			current = current.getLeft();
  		}
          else {
  			isLeftChild = false;
  			current = current.getRight();
  		}
  		if (current == null){
  			return false;
  		}
  	}
  	//Case 1: 자식노드가 없는 경우
  	if (current.getLeft()==null && current.getRight()==null){
  		if (current==root){
  			root = null;
  		}
  		if (isLeftChild==true){
  			parent.setLeft(null);
  		}
          else{
  			parent.setRight(null);
  		}
  	}
  	//Case 2: 하나의 자식을 갖는 경우
  
  	else if (current.getRight()==null){
  		if (current==root){
  			root = current.getLeft();
  		}
          else if (isLeftChild){
  			parent.setLeft(current.getLeft());
  		}
          else{
  			parent.setRight(current.getLeft());
  		}
  	}
      else if (current.getLeft()==null){
  		if (current==root){
  			root = current.getRight();
  		}
          else if (isLeftChild){
  			parent.setLeft(current.getRight());
  		}
          else{
  			parent.setRight(current.getRight());
  		}
  	}
  	//Case 3: 두개의 자식을 갖는 경우
  	else if (current.getLeft()!=null && current.getRight()!=null){
  		// 오른쪽 서브트리의 값중 가장 작은 값을 택하는 경우로 구현
  		Node successor = getSuccessor(current);
  		if (current==root){
  			root = successor;
  		}
          else if (isLeftChild){
  			parent.setLeft(successor);
  		}
          else{
  			parent.setRight(successor);
  		}			
  		successor.setLeft(current.getLeft());
  	}		
  	return true;		
  }
  
  public Node getSuccessor(Node deleleNode){
  	Node successsor = null;
  	Node successsorParent = null;
  	Node current = deleleNode.getRight();
  	while (current!=null){
  		successsorParent = successsor;
  		successsor = current;
  		current = current.getLeft();
  	}
      // succeessor에 오른쪽 서브트리 중 가장 작은 노드가 들어옴
      
      // 이 노드가 지울 노드와 직접 연결되어 있다면 바로 리턴하여 붙이면 되고,
      
      // 이 노드가 지울 노드와 직접 연결되어 있지 않다면
  	if (successsor!=deleleNode.getRight()){
          // 이 노드가 있어야 할 자리(sP의 왼쪽 자식)를 이 노드의 오른쪽 자식(왼쪽 자식은 없을것임)으로 채우고,
  		successsorParent.setLeft(successsor.getRight());
          // 이 노드의 오른쪽 자식을 오른쪽 서브트리로 채운다.
  		successsor.setRight(deleleNode.getRight());
  	}
  	return successsor;
  }
  ```

- 트리 생성

- 트리 삭제

##### 시간복잡도

- 균등 트리: O(logN)
- 편향 트리: O(N)
  - 이렇게 한쪽만 뻗어있는 편향 트리는 시간복잡도가 O(N)이 나오므로 트리를 사용할 이유가 사라짐..
  - 이를 바로잡도록 개선된 트리가 AVL Tree, RedBlack Tree (self-balanced tree)

즉, 시간복잡도는 트리의 depth에 비례

### 해시(Hash)

- 데이터의 효율적 관리를 위해, <u>임의의 길이 데이터</u>를 <u>고정된 길이의 데이터</u>로 매핑
- 해시 함수를 구현하여 데이터 값을 해시값으로 매핑
  - 그런데 데이터가 많아지면 서로 다른 데이터가 같은 해시값으로 충돌나는 현상이 발생하게 됨(collision)

##### 해시 테이블을 쓰는 이유

- 적은 자원으로 많은 데이터를 효율적으로 관리하기 위해!
- 언제나 동일한 해시값을 return하므로 index를 알면 빠른 데이터 검색 가능
- 시간복잡도 O(1)
  - 이진탐색트리는 O(logN)

##### 충돌 문제 해결

- 체이닝

  <img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201120025756163.png" alt="image-20201120025756163" style="zoom: 67%;" /> 

  - linked list로 노드를 계속 추가해 나가는 방식
  - 장점: 제한 없이 계속 연결 가능
  - 단점: 메모리 문제

- Open addressing

  <img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201120025847694.png" alt="image-20201120025847694" style="zoom:67%;" /> 

  - 해시함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용
    - 해당 키 값에 이미 저장이 되어있으면 다음 주소로 가도록
    - 장점: 메모리 문제가 발생하지 않음
    - 단점: 해시 충돌이 발생할 수 있음

- 선형 탐사

  <img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201120030500135.png" alt="image-20201120030500135" style="zoom:67%;" /> 

  - 정해진 고정 폭으로 옮겨 해시값의 중복을 피함
  - 단점: 이동폭이 고정되어 있어 특정 해시값 주변 버킷이 모두 채워져 있는 primary clustering 문제에 취약

- 제곱 탐사

- ![image-20201120030445188](C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201120030445188.png) 

  - 정해진 고정 폭을 제곱수로 옮겨 해시값의 중복을 피함
  - 처음에 1칸, 또 충돌이면 (원래 위치로부터) 4칸, 또 충돌이면 (원래 위치로부터) 9칸
  - 단점: 여러개의 서로 다른 키들이 동일한 초기 해시값을 갖는 secondary clustering에 취약
    - ![image-20201120031050302](C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201120031050302.png) 
    - 위와 같이 13으로 나눈 나머지를 저장할 때, 15, 28, 41, 54, 67이 모두 같은 해시값을 가질 때 멀리씩 점프해도 연산수가 줄어들지 않는 현상
    - 선형 탐사에서도 같은 현상이 발생하겠지만, 제곱 탐사는 식이 더 복잡한데도 문제가 해결이 안된다는 의미에서 단점이라고 한듯

### 트라이(Trie)

**문자열**에서 검색을 빠르게 도와주는 자료구조

- 정수 데이터들에서 BST를 이용하면 O(logN)
- 하지만 문자열 데이터들에서 BST를 이용하면 문자열 최대 길이가 M일 때 O(MlogN)..
- 트라이를 사용하면 **O(M)**

<img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201120031534465.png" alt="image-20201120031534465" style="zoom:67%;" />

```java
static class Trie { // ???
    boolean end;
    boolean pass;
    Trie[] child;

    Trie() {
        end = false;
        pass = false;
        child = new Trie[10];
    }

    public boolean insert(String str, int idx) {

        //끝나는 단어 있으면 false 종료
        if (end) return false;

        //idx가 str만큼 왔을때
        if (idx == str.length()) {
            end = true;
            if (pass) return false; // 더 지나가는 단어 있으면 false 종료
            else return true;
        }
        //아직 안왔을 때
        else {
            int next = str.charAt(idx) - '0';
            if (child[next] == null) {
                child[next] = new Trie();
                pass = true;
            }
            return child[next].insert(str, idx+1);
        }

    }
}
```

### B Tree & B+ Tree

<span style="color:red">대충 훑어서 이해 잘 안됨. 나중에 필요할 것 같으면 더 자세히 보자</span>

- 이진트리는 하나의 부모가 두개의 자식밖에 가지지 못하며, 균형이 맞지 않으면 검색 효율이 선형검색 급으로 떨어짐
- 하지만 이진트리 구조의 간결함과 균형이 맞다면 검색, 삽입, 삭제 모두 O(logN)의 성능을 보이는 장점이 있으므로 이를 활용하는 것이 중요!

#### B Tree

이진트리를 확장해서, **더 많은 수의 자식을 가질 수 있게 일반화**시킨 트리 자료구조의 일종

- 자식 수의 일반화
  - 하나의 노드 아래에 더 저장될 수 있을 뿐만 아니라
  - 트리의 균형을 자동으로 맞춰줌
  - 즉, 단순하고 효율적이며 균형을 맞추고 있는 트리!

- 데이터베이스, 파일 시스템에서 널리 사용됨
  - 대량의 데이터를 처리해야 할 때, 검색 구조의 경우 하나의 노드에 많은 데이터를 가질 수 있다는 점은 상당히 큰 장점이다.
    - 대량의 데이터는 메모리보다 블럭 단위로 입출력하는 하드디스크 or SSD에 저장해야하기 때문!
    - ex) 한 블럭이 1024 바이트면, 2바이트를 읽으나 1024바이트를 읽으나 똑같은 입출력 비용 발생. 따라서 하나의 노드를 모두 1024바이트로 꽉 채워서 조절할 수 있으면 입출력에 있어서 효율적인 구성을 갖출 수 있다.
  - B-Tree는 이러한 장점을 토대로 많은 데이터베이스 시스템의 인덱스 저장 방법으로 애용하고 있음

##### 규칙

- 노드의 자료 수가 N개면 자식 수는 N+1 이어야 함
- 각 노드의 자료는 정렬된 상태여야 함
- 루트 노드는 적어도 2개 이상의 자식을 가져야 함
- 루트 노드를 제외한 모든 노드는 적어도 M/2개의 자료를 가지고 있어야 함
- 외부 노드로 가는 경로의 길이는 모두 같음
- 입력 자료 중복 X

#### B+ Tree

기존의 B-Tree와 데이터의 linked list로 구현된 색인 구조

- 데이터의 빠른 접근을 위한 index 역할만 하는 non-leaf 노드가 추가로 있음
- B-Tree의 변형 구조(index + leaf)
  - 인덱스 부분의 key값은 leaf에 있는 key값을 직접 찾아가는데 사용

##### 장점

- 블럭 사이즈를 더 많이 이용할 수 있음(key값에 대한 하드디스크 액세스 주소가 없으므로)
- leaf 노드끼리 linked list로 연결되어 있어 범위 탐색에 유리

##### 단점

- B-Tree의 경우 최선의 경우 루트에서 끝날 수 있는데, B+ Tree는 무조건 leaf까지 내려가봐야 함

#### 비교

- B-Tree는 각 노드에 데이터가 저장되지만, B+Tree는 index노드와 leaf노드로 분리되어 저장됨
  - leaf 노드는 서로 연결되어 있어서 임의접근/순차접근 모두 우수한 성능
- B-Tree는 각 노드에서 key, data 모두 들어갈 수 있고, data는 disk block으로 포인터가 될 수 있음.. 그러나 B+Tree는 각 노드에서 key만 들어가므로 data는 모두 leaf만 존재
- B+Tree는 add와 delete 모두 leaf에서만 이루어짐

## Operating System 운영체제

### 운영체제란?

하드웨어 관리 & 응용프로그램-하드웨어 간 인터페이스 & 시스템 동작 제어

**시스템의 자원과 동작을 관리하는 소프트웨어**

#### 프로세스 관리

프로세스, 스레드 / 스케줄링 / 동기화 / IPC 통신

- OS에서 작동하는 응용 프로그램을 관리
- 프로세서(CPU) 관리로도 볼 수 있음
  - 현재 CPU를 점유해야 할 프로세스를 결정하고,
  - CPU를 프로세스에 할당하며
  - 프로세스 간 공유자원 접근과 통신 관리

#### 저장장치 관리

메모리 관리 / 가상 메모리 / 파일 시스템

- 1차 저장장치(메인 메모리)
  - 프로세스에 할당하는 메모리 영역 할당/해제
  - 메모리 영역 간 침범 방지
  - 메인 메모리 효율적 활용을 위한 가상 메모리 기능
- 2차 저장장치(HDD, NAND 플래시 메모리 등)
  - 파일 형식 데이터 저장
  - 파일 데이터 관리를 위한 파일시스템을 os에서 관리

#### 네트워킹

TCP/IP / 기타 프로토콜

- 인터넷에 연결하거나 네트워크 사용을 위해 **네트워크 프로토콜 지원**
- 사용자와 하드웨어 사이에서 제어/관리하는 셈



#### 사용자 관리

계정 관리 / 접근권한 관리

- 각 계정을 관리할 수 있는 기능
  - 사용자별 프라이버시 및 보안을 위해
- 파일이나 시스템 자원에 접근 권한 지정

#### 디바이스 드라이버

순차접근 장치 / 임의접근 장치 / 네트워크 장치

- 시스템에 연결된 하드웨어를 운영체제에서 인식하고 관리
  - 응용프로그램이 하드웨어를 사용할 수 있도록!
- 하드웨어를 추상화 해주는 계층 필요(= 디바이스 드라이버)
- 이러한 디바이스 드라이버를 관리

### 프로세스와 스레드

- **프로세스**: 프로그램을 메모리 상에서 실행중인 작업

  <img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201120202801434.png" alt="image-20201120202801434" style="zoom:67%;" /> 

  - 각각 별도의 독립적 주소공간 할당
    - Code: 코드 자체를 구성하는 메모리 영역(프로그램 명령)
    - Data: 전역변수, 정적변수, 배열 등(초기화된 데이터)
    - Heap: 동적 할당 시 사용(new(), malloc() 등)
    - Stack: 지역변수, 매개변수, 리턴값(임시 메모리 영역)
      - 스레드마다 따로 할당

- **스레드**: 프로세스 안에서 실행되는 여러 흐름 단위

  - 하나의 프로세스가 생성될 때 기본적으로 하나의 스레드가 같이 생성됨
  - 스택만 따로 할당받고, 나머지 영역은 스레드들끼리 공유

- 차이점) 프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하지만, 스레드는 다른 스레드와 공간과 자원을 공유하면서 사용

#### 멀티프로세스

하나의 컴퓨터에 여러 CPU(프로세서), 즉 여러 프로세스를 동시에 처리(병렬)

- 장점: 안전성(메모리 침범 문제를 OS차원에서 해결)
- 단점: 각각 독립된 메모리 영역을 갖고 있어 작업량 많아질 수록 오버헤드 발생, Context switching으로 인한 성능 저하
  - Context Switching: 프로세스의 상태 정보를 저장 및 복원하는 과정
  - 프로세스가 각 독립된 메모리 영역을 할당받아 사용하므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되면 오버헤드가 발생할 수 있음..



#### 멀티스레드

하나의 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리

- 스레드들이 공유 메모리를 통해 여러 작업을 동시에 처리
- 장점: 공유 메모리를 사용함에 따른 시간 및 자원 손실이 감소, 전역/정적 변수에 대한 자료 공유 가능
- 단점: 안전성 문제, 하나의 스레드가 데이터 공간을 망가뜨리면 모든 스레드가 작동 불능(공유 메모리를 가지므로)
  - 안전성 문제는 Critical section 기법(하나의 스레드가 공유 데이터값을 변경하는 시점에 다른 스레드가 그 읽으려할 때 발생하는 문제를 해결하기 위한 동기화 과정)을 통해 대비할 수 있음
    - 상호 배제, 진행, 한정된 대기를 충족해야 함

### 프로세스 주소 공간

프로그램이 CPU에 의해 실행되면, 프로세스가 생성되고 메모리에 프로세스 주소공간이 할당된다.

- 코드 + 데이터 + 스택으로 이루어져 있음
  - 코드 segment: 프로그램 소스 코드 저장
  - 데이터 segment: 전역변수 저장
  - 스택 segment: 함수, 지역변수 저장
  - 최대한 데이터를 공유하여 메모리 사용량을 줄이기 위해 구역을 나눈다.
    - 코드의 경우 같은 프로그램에서는 다 같은 내용일 것

### 인터럽트(Interrupt)

##### 정의

프로그램 실행 도중 예기치 못한 상황(더 중요한 일.. ex. 입출력, 우선순위 연산 등)이 발생했을 경우

현재 실행중인 작업을 즉시 중단하고

발생된 상황을 우선 처리한 후

실행중이던 작업으로 복귀하여 계속 처리하는 것

- 하드웨어 인터럽트
  - CPU 외부 하드웨어장비에 의해 발생
  - 타이머, I/O장비 등
- 소프트웨어 인터럽트(= Exception)
  - 명령어 실행 도중 CPU에 의해 발생
  - 0으로 나누기, 세그폴트, 페이지폴트, 부동소수점 오류, 시스템콜, ...

#### 인터럽트 발생 처리 과정

![image-20201120223158362](C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201120223158362.png) 

##### 만약 인터럽트 기능이 없었다면?

컨트롤러는 특정 task를 수행할 시기를 알기 위해 계속 체크를 해야 함(폴링, polling)

→ 이 경우 원래 하는 일에 집중할 수 없게 되어 많은 기능을 제대로 수행하지 못함

인터럽트는 실시간 대응에 있어서 필수적인 기능!

### 시스템 콜(System Call)

- fork(), exec(): 새로운 프로세스 생성
  - parent의 fork()값: child의 pid값, child의 fork()값: 0
- wait(): 프로세스(부모)가 만든 다른 프로세스(자식)가 긑날 때까지 기다리는 명령어

### PCB와 Context Switching

<span style="color:red">X</span>

### IPC(Inter Process Communication)

<span style="color:red">X</span>

### CPU 스케줄링

CPU의 효율적인 사용을 위해 프로세스를 잘 배정해야 한다.

- 조건: 오버헤드, starvation ↓ / 사용률 ↑
- 목표
  1. Batch system: 가능한 많은 일 수행.. 처리량
  2. Interactive system: 빠른 응답 시간 및 적은 대기 시간
  3. Real-time system: 데드라인 맞추기

#### 선점/비선점 스케줄링

- 선점(preemptive): OS가 CPU의 사용권을 선점 및 강제 회수 가능
  - Ex) I/O, Event wait
- 비선점(non-preemptive): 프로세스가 종료되거나 I/O 이벤트가 있을 때까지 실행 보장
  - 처리시간 예측이 어려움
  - Ex) Interrupt, Scheduler Dispatch

#### 상태

<img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201120224637181.png" alt="image-20201120224637181" style="zoom:67%;" /> 

#### 스케줄링의 종류

- 비선점 스케줄링
  - FCFS(First Come First Served)
  - SJF(Shortest Job First)
- 선점 스케줄링
  - Priority Scheduling
    - starvation 문제 발생 가능
  - Round Robin
  - Multilevel-Queue
  - Multilevel-Feedback-Queue

#### 스케줄링 척도

- Response Time: 작업이 처음 실행되기까지 걸린 시간
- Turnaround Time: 대기시간과 실행시간을 모두 합한 시간(작업 완료까지 걸린 시간)

### 데드락(Deadlock)

프로세스가 자원을 얻지 못해서 다음 처리를 하지 못하는 상태

#### 발생 조건

1. **상호 배제(Mutual exclusion)**: 자원은 한번에 한 프로세스만 사용 가능
2. **점유 대기(Hold and wait)**: 최소 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당된 자원을 추가적으로 점유하기 위해 대기하는 프로세스가 존재해야 함
3. **비선점(No preemption)**: 다른 프로세스에 할당된 자원은 강제로 빼앗을 수 없음
4. **순환 대기(Circular wait)**: 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함

#### 처리

- 예방(Prevention)
  - 데드락 발생 조건 중 하나를 제거하면서 해결
    - 상호배제 부정 : 여러 프로세스가 공유 자원 사용
    - 점유대기 부정 : 프로세스 실행전 모든 자원을 할당
    - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
    - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구
  - 단점: 자원 낭비가 심함
- 회피(Avoidance)
  - 데드락 발생 시 피해나가는 방법
  - Ex) 은행원 알고리즘
    - 모든 고객의 요구가 충족되도록 현금 할당
    - 프로세스가 자원을 요구할 때, 시스템은 <u>자원을 할당한 후에도 안정 상태인지 사전에 검사</u>하여 교착 상태를 회피
    - 안정 상태면 자원 할당, 아니면 자원 해지까지 대기
- 탐지(Detection)
  - 자원 할당 그래프를 통해 데드락 탐지
  - 단점: 자원 요청 시 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생
- 회복(Recovery)
  - 데드락을 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복
  - 프로세스 종료의 경우
    - 데드락 상태의 모든 프로세스를 중지
    - 데드락이 제거될 때까지 데드락 상태의 프로세스를 하나씩 중지
  - 자원 선점의 경우
    - 데드락 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에 할당(해당 프로세스 일시정지)
    - priority가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점

### 경쟁 상태(Race Condition)

<span style="color:red">X</span>

### 세마포어와 뮤텍스

### 페이징과 세그먼테이션

### 페이지 교체 알고리즘

페이지 부재 발생 → 새로운 페이지를 할당해야 함 → 현재 할당된 페이지 중 어떤 것 교체할 지 결정하는 방법

- FIFO(First-in First-out) 알고리즘: 가장 먼저 올라온 페이지를 먼저 내보냄

  <img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201120235322260.png" alt="image-20201120235322260" style="zoom:67%;" />

- OPT(Optimal) 알고리즘: 앞으로 가장 사용하지 않을 페이지를 먼저 내보냄(**미래**)

  <img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201120235338896.png" alt="image-20201120235338896" style="zoom:67%;" />

  - 4번째에서 7,0,1 중 가장 나중에 다시 사용되는 7을 빼고 2를 불러온다.

  - 장점: FIFO에 비해 페이지 결함의 수를 감소시킬 수 있음
  - 단점: 그러나 실질적으로 페이지가 앞으로 잘 사용되지 않을 것이라는 보장을 할 수 없으므로 수행이 어렵다

- LRU(Least-Recently-Used) 알고리즘: 최근에 사용하지 않은 페이지를 먼저 내보냄(**과거**)

  <img src="C:\Users\KJH\AppData\Roaming\Typora\typora-user-images\image-20201120235445319.png" alt="image-20201120235445319" style="zoom:67%;" />

  - 6번째 페이지 폴트에서 2,0,3 중 가장 예전에 사용된 2가 교체됨
  - Global 교체: 메모리 상의 모든 프로세스 페이지에 대해 교체
  - Local 교체: 메모리 상의 자기 프로세스 페이지에서만 교체
  - 자기 프로세스 페이지에서만 교체를 하면 교체 시 각각 모두 교체를 해야 하므로 실제로는 Global 교체가 더 효율적임

### 메모리(Memory)

<span style="color:red">X</span>

### 파일 시스템(File System)

<span style="color:red">X</span>

## Database 데이터베이스

### 키(Key)

### 조인(Join)

### SQL Injection

### SQL vs NOSQL

### 이상(Anomaly)

### 인덱스(Index)

### 트랜잭션(Transaction)

### 트랜잭션 격리 수준

### 레디스(Redis)

## Network 네트워크

### OSI 7계층

### TCP 3 & 4 way handshake

### TCP/IP 흐름제어 & 혼잡제어

### UDP

### 대칭키 & 공개키

### HTTP & HTTPS

### 로드밸런싱(Load Balancing)

### Blocking & Non-Blocking I/O

## Software Engineering 소프트웨어 공학

<span style="color:red">X</span>

### 클린코드 & 리팩토링

### 클린코드 & 시큐어 코딩

### 테스트 주도 개발(TDD)

### 애자일(Agile)

### 객체 지향 프로그래밍

### 함수형 프로그래밍

### 데브옵스(DevOps)

### 서브파티(3rd party)